package tag_test

import (
	"context"
	"crypto/ed25519"
	"testing"
	"time"

	model_core "bonanza.build/pkg/model/core"
	model_tag "bonanza.build/pkg/model/tag"
	model_initialsizeclass_pb "bonanza.build/pkg/proto/model/initialsizeclass"
	"bonanza.build/pkg/storage/dag"
	"bonanza.build/pkg/storage/object"
	"bonanza.build/pkg/storage/tag"

	"github.com/buildbarn/bb-storage/pkg/testutil"
	"github.com/buildbarn/bb-storage/pkg/util"
	"github.com/stretchr/testify/require"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	"go.uber.org/mock/gomock"
)

func TestStorageBackedMutableProtoStore(t *testing.T) {
	ctrl, ctx := gomock.WithContext(context.Background(), t)

	tagResolver := NewMockResolverForTesting(ctrl)
	messageObjectReader := NewMockMessageObjectReaderForTesting(ctrl)
	objectEncoder := NewMockKeyedBinaryEncoder(ctrl)
	dagUploader := NewMockDAGUploaderForTesting(ctrl)
	clock := NewMockClock(ctrl)
	store := model_tag.NewStorageBackedMutableProtoStore(
		object.SHA256V1ReferenceFormat,
		tagResolver,
		ed25519.PrivateKey{
			0xd4, 0xab, 0xcf, 0x6e, 0x75, 0xf0, 0x38, 0x68,
			0x87, 0x5f, 0x1a, 0x1a, 0x1f, 0xc9, 0xfa, 0x83,
			0x9e, 0xa2, 0xd3, 0x5a, 0x41, 0xca, 0xee, 0x06,
			0x9c, 0x32, 0x69, 0x4b, 0x60, 0x72, 0x79, 0xb7,
			0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
			0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
			0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
			0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
		},
		messageObjectReader,
		objectEncoder,
		dagUploader,
		clock,
	)

	objectEncoder.EXPECT().GetDecodingParametersSizeBytes().Return(12).AnyTimes()

	if false {
		t.Run("InitialStorageGetFailure", func(t *testing.T) {
			// Errors should be propagated from the backend.
			tagResolver.EXPECT().ResolveTag(
				gomock.Any(),
				object.SHA256V1ReferenceFormat,
				tag.Key{
					SignaturePublicKey: [...]byte{
						0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
						0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
						0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
						0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
					},
					Hash: [...]byte{
						0x98, 0xf3, 0xb4, 0x31, 0x35, 0x63, 0x70, 0x22,
						0x7b, 0x61, 0xbf, 0x3d, 0x23, 0x2f, 0xd0, 0x30,
						0x49, 0xb4, 0x7c, 0xec, 0x89, 0xf3, 0x02, 0x05,
						0x97, 0xf7, 0x6c, 0xcf, 0xac, 0x0b, 0x97, 0x4c,
					},
				},
				/* minimumTimestamp = */ nil,
			).Return(tag.SignedValue{}, false, status.Error(codes.Internal, "Storage failure"))

			_, err := store.Get(
				ctx,
				util.Must(
					model_core.NewDecodable(
						/* tagKeyHash = */ [...]byte{
							0x98, 0xf3, 0xb4, 0x31, 0x35, 0x63, 0x70, 0x22,
							0x7b, 0x61, 0xbf, 0x3d, 0x23, 0x2f, 0xd0, 0x30,
							0x49, 0xb4, 0x7c, 0xec, 0x89, 0xf3, 0x02, 0x05,
							0x97, 0xf7, 0x6c, 0xcf, 0xac, 0x0b, 0x97, 0x4c,
						},
						/* decodingParameters = */ []byte{
							0x2d, 0x5d, 0x6f, 0xac, 0xab, 0x08, 0x48, 0x2d,
							0x65, 0xe5, 0xec, 0x8a,
						},
					),
				),
			)
			testutil.RequireEqualStatus(t, status.Error(codes.Internal, "Failed to resolve tag with key hash 98f3b431356370227b61bf3d232fd03049b47cec89f3020597f76ccfac0b974c: Storage failure"), err)
		})

		t.Run("EmptyMessages", func(t *testing.T) {
			// Reading a number of nonexistent messages should
			// succeed and not trigger any writes against storage.
			tagResolver.EXPECT().ResolveTag(
				gomock.Any(),
				object.SHA256V1ReferenceFormat,
				tag.Key{
					SignaturePublicKey: [...]byte{
						0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
						0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
						0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
						0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
					},
					Hash: [...]byte{
						0xef, 0xb2, 0xb7, 0x9d, 0xfc, 0xb4, 0x90, 0xc6,
						0x91, 0xc5, 0xd3, 0xac, 0xea, 0x75, 0x55, 0x02,
						0xef, 0x8e, 0x0a, 0xc4, 0x0f, 0xa2, 0x10, 0xf0,
						0xe8, 0x5a, 0xad, 0x19, 0x4f, 0x4d, 0x03, 0x59,
					},
				},
				/* minimumTimestamp = */ nil,
			).Return(tag.SignedValue{}, false, status.Error(codes.NotFound, "Tag does not exist"))

			handle1, err := store.Get(
				ctx,
				util.Must(
					model_core.NewDecodable(
						/* tagKeyHash = */ [...]byte{
							0xef, 0xb2, 0xb7, 0x9d, 0xfc, 0xb4, 0x90, 0xc6,
							0x91, 0xc5, 0xd3, 0xac, 0xea, 0x75, 0x55, 0x02,
							0xef, 0x8e, 0x0a, 0xc4, 0x0f, 0xa2, 0x10, 0xf0,
							0xe8, 0x5a, 0xad, 0x19, 0x4f, 0x4d, 0x03, 0x59,
						},
						/* decodingParameters = */ []byte{
							0x85, 0x42, 0x37, 0xd6, 0xe6, 0x58, 0x95, 0x20,
							0x23, 0x03, 0xad, 0xe8,
						},
					),
				),
			)
			require.NoError(t, err)
			testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{}, handle1.GetMutableProto())
			handle1.Release(false)

			tagResolver.EXPECT().ResolveTag(
				gomock.Any(),
				object.SHA256V1ReferenceFormat,
				tag.Key{
					SignaturePublicKey: [...]byte{
						0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
						0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
						0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
						0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
					},
					Hash: [...]byte{
						0x69, 0x48, 0x1a, 0x1b, 0x72, 0xb2, 0xc6, 0xbe,
						0x55, 0xcf, 0xf0, 0x77, 0x6b, 0x40, 0x98, 0x00,
						0x87, 0x86, 0xe3, 0x3a, 0xb3, 0xff, 0xc1, 0x3b,
						0x22, 0xdd, 0x3a, 0x3c, 0x64, 0xae, 0x07, 0xe4,
					},
				},
				/* minimumTimestamp = */ nil,
			).Return(tag.SignedValue{}, false, status.Error(codes.NotFound, "Tag does not exist"))

			handle2, err := store.Get(
				ctx,
				util.Must(
					model_core.NewDecodable(
						/* tagKeyHash = */ [...]byte{
							0x69, 0x48, 0x1a, 0x1b, 0x72, 0xb2, 0xc6, 0xbe,
							0x55, 0xcf, 0xf0, 0x77, 0x6b, 0x40, 0x98, 0x00,
							0x87, 0x86, 0xe3, 0x3a, 0xb3, 0xff, 0xc1, 0x3b,
							0x22, 0xdd, 0x3a, 0x3c, 0x64, 0xae, 0x07, 0xe4,
						},
						/* decodingParameters = */ []byte{
							0xad, 0x39, 0x02, 0xcd, 0xda, 0x8f, 0xac, 0x7e,
							0xd0, 0xf6, 0x42, 0x2f,
						},
					),
				),
			)
			require.NoError(t, err)
			testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{}, handle2.GetMutableProto())
			handle2.Release(false)

			tagResolver.EXPECT().ResolveTag(
				gomock.Any(),
				object.SHA256V1ReferenceFormat,
				tag.Key{
					SignaturePublicKey: [...]byte{
						0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
						0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
						0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
						0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
					},
					Hash: [...]byte{
						0x4b, 0xba, 0x6a, 0xc0, 0xae, 0xd8, 0x28, 0x0b,
						0x8d, 0xd5, 0x5a, 0xff, 0x17, 0x3e, 0x1f, 0x44,
						0xdc, 0x57, 0x52, 0xbe, 0xb5, 0xc1, 0xc0, 0xaa,
						0x7e, 0x50, 0x19, 0x36, 0xd3, 0x8c, 0xfb, 0xd4,
					},
				},
				/* minimumTimestamp = */ nil,
			).Return(
				tag.SignedValue{
					Value: tag.Value{
						Reference: object.MustNewSHA256V1LocalReference("3250098f48db602cebb68068ab3e22739007002f314a75d17cb6106e91dcdc5f", 4245, 0, 0, 0),
						Timestamp: time.Unix(1763393799, 0),
					},
				},
				/* complete = */ false,
				nil,
			)

			handle3, err := store.Get(
				ctx,
				util.Must(
					model_core.NewDecodable(
						/* tagKeyHash = */ [...]byte{
							0x4b, 0xba, 0x6a, 0xc0, 0xae, 0xd8, 0x28, 0x0b,
							0x8d, 0xd5, 0x5a, 0xff, 0x17, 0x3e, 0x1f, 0x44,
							0xdc, 0x57, 0x52, 0xbe, 0xb5, 0xc1, 0xc0, 0xaa,
							0x7e, 0x50, 0x19, 0x36, 0xd3, 0x8c, 0xfb, 0xd4,
						},
						/* decodingParameters = */ []byte{
							0x31, 0x5e, 0xe3, 0x5d, 0xc0, 0x65, 0x9c, 0x59,
							0x63, 0xcd, 0xc6, 0xf1,
						},
					),
				),
			)
			require.NoError(t, err)
			testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{}, handle3.GetMutableProto())
			handle3.Release(false)
		})
	}

	t.Run("ReusingHandle", func(t *testing.T) {
		// Create a handle that is backed by an existing stats
		// message stored in the Initial Size Class Cache.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
					0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
					0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
					0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
				},
			},
			/* minimumTimestamp = */ nil,
		).Return(
			tag.SignedValue{
				Value: tag.Value{
					Reference: object.MustNewSHA256V1LocalReference("80f8626ce2a9cc67c144e593bb9ee7a1976a1907e221f1becbfe69d67fe3df92", 100, 0, 0, 0),
					Timestamp: time.Unix(1620819000, 0),
				},
			},
			/* complete = */ true,
			nil,
		)
		messageObjectReader.EXPECT().ReadObject(
			gomock.Any(),
			util.Must(model_core.NewDecodable(
				object.MustNewSHA256V1LocalReference("80f8626ce2a9cc67c144e593bb9ee7a1976a1907e221f1becbfe69d67fe3df92", 100, 0, 0, 0),
				[]byte{0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a, 0x57, 0xe3, 0xd9, 0x06},
			)),
		).Return(model_core.NewSimpleMessage[object.LocalReference](&model_initialsizeclass_pb.PreviousExecutionStats{
			SizeClasses:     map[uint32]*model_initialsizeclass_pb.PerSizeClassStats{},
			LastSeenFailure: &timestamppb.Timestamp{Seconds: 1620818827},
		}), nil)

		handle1, err := store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
						0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
						0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
						0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
					},
					/* decodingParameters = */ []byte{
						0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a,
						0x57, 0xe3, 0xd9, 0x06,
					},
				),
			),
		)
		require.NoError(t, err)
		testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{
			SizeClasses:     map[uint32]*model_initialsizeclass_pb.PerSizeClassStats{},
			LastSeenFailure: &timestamppb.Timestamp{Seconds: 1620818827},
		}, handle1.GetMutableProto())

		// Because the first handle hasn't been released, we can
		// create other handles without causing the first handle
		// to be flushed.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0xdd, 0x56, 0x8a, 0x7d, 0x82, 0x4a, 0x1f, 0x89,
					0xda, 0xf0, 0xd1, 0x69, 0xf9, 0xb4, 0x0c, 0xca,
					0xc8, 0x78, 0x0f, 0x72, 0x92, 0xe0, 0xd7, 0xf0,
					0xb3, 0x9a, 0xe2, 0x1c, 0x5a, 0xdb, 0x4d, 0x3c,
				},
			},
			/* minimumTimestamp = */ nil,
		).Return(tag.SignedValue{}, false, status.Error(codes.NotFound, "Tag does not exist"))

		handle2, err := store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0xdd, 0x56, 0x8a, 0x7d, 0x82, 0x4a, 0x1f, 0x89,
						0xda, 0xf0, 0xd1, 0x69, 0xf9, 0xb4, 0x0c, 0xca,
						0xc8, 0x78, 0x0f, 0x72, 0x92, 0xe0, 0xd7, 0xf0,
						0xb3, 0x9a, 0xe2, 0x1c, 0x5a, 0xdb, 0x4d, 0x3c,
					},
					/* decodingParameters = */ []byte{
						0xb9, 0xc8, 0x05, 0x25, 0x74, 0x5e, 0xfd, 0xa7,
						0x12, 0xed, 0x55, 0x67,
					},
				),
			),
		)
		require.NoError(t, err)
		testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{}, handle2.GetMutableProto())
		handle2.Release(false)

		// Modify and release the original handle. This should
		// normally cause the next call to Get() to write it...
		handle1.GetMutableProto().LastSeenFailure = &timestamppb.Timestamp{Seconds: 1620819007}
		handle1.Release(true)

		// ... except if the next call to Get() requests the
		// same handle. We should simply reuse the original one.
		handle3, err := store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
						0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
						0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
						0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
					},
					/* decodingParameters = */ []byte{
						0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a,
						0x57, 0xe3, 0xd9, 0x06,
					},
				),
			),
		)
		require.NoError(t, err)
		testutil.RequireEqualProto(t, &model_initialsizeclass_pb.PreviousExecutionStats{
			SizeClasses:     map[uint32]*model_initialsizeclass_pb.PerSizeClassStats{},
			LastSeenFailure: &timestamppb.Timestamp{Seconds: 1620819007},
		}, handle3.GetMutableProto())

		// Release it once again. Even though we did not make
		// any changes to it, it's still dirty. This means the
		// next call to Get() should still try to write it.
		handle1.Release(false)

		// Let the next call to Get() write the old handle.
		// Unfortunately, at the same time we see a failure
		// reading the new handle, meaning the write is
		// interrupted.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0xd8, 0xb9, 0x0d, 0x29, 0xf2, 0x81, 0xf6, 0x0f,
					0x2a, 0xb2, 0xd7, 0x7c, 0xfb, 0x92, 0xfc, 0x60,
					0x08, 0x04, 0xdc, 0x0f, 0x64, 0x02, 0x96, 0x5c,
					0x56, 0xe3, 0xfb, 0x67, 0xc8, 0x6a, 0x28, 0x17,
				},
			},
			/* minimumTimestamp = */ nil,
		).Return(tag.SignedValue{}, false, status.Error(codes.Internal, "Storage failure"))
		objectEncoder.EXPECT().EncodeBinary(
			/* input = */ []byte{0x12, 0x06, 0x08, 0xbf, 0xf8, 0xee, 0x84, 0x06},
			/* decodingParameters = */ []byte{0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a, 0x57, 0xe3, 0xd9, 0x06},
		).Return([]byte{0xa6, 0xed, 0x16, 0xdd, 0x82, 0x27, 0xc5, 0x4d}, nil)
		clock.EXPECT().Now().Return(time.Unix(1620819007, 0))
		dagUploader.EXPECT().UploadTaggedDAG(
			gomock.Any(),
			struct{}{},
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
					0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
					0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
					0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
				},
			},
			tag.SignedValue{
				Value: tag.Value{
					Reference: object.MustNewSHA256V1LocalReference("572b3a27c3d52fc3eed60c1e591a6477e29a1ca24eb03f87dcade2cdfdc0cf09", 8, 0, 0, 0),
					Timestamp: time.Unix(1620819007, 0),
				},
				Signature: [...]byte{
					0x1a, 0xff, 0x84, 0xd9, 0xc4, 0x6c, 0x89, 0xe9,
					0x4a, 0xd3, 0xfa, 0x1d, 0x7f, 0x69, 0xf9, 0x41,
					0xf0, 0x67, 0x91, 0xf7, 0x77, 0xcd, 0xdc, 0xb1,
					0xb5, 0xd7, 0x72, 0xd7, 0xd0, 0x1b, 0x3f, 0x63,
					0xa7, 0xf3, 0xb9, 0xb5, 0x52, 0x0c, 0xed, 0x80,
					0xea, 0x72, 0x4a, 0x4a, 0x0c, 0x02, 0xfd, 0x62,
					0x31, 0xe9, 0x76, 0x42, 0xb0, 0x0d, 0xb8, 0x2f,
					0x3e, 0x93, 0x4b, 0x67, 0x77, 0x7d, 0x6e, 0x05,
				},
			},
			gomock.Any(),
		).DoAndReturn(func(ctx context.Context, namespace struct{}, rootTagKey tag.Key, rootTagSignedValue tag.SignedValue, rootObjectContentsWalker dag.ObjectContentsWalker) error {
			<-ctx.Done()
			require.Equal(t, context.Canceled, ctx.Err())
			rootObjectContentsWalker.Discard()
			return status.Error(codes.Canceled, "Request canceled")
		})

		_, err = store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0xd8, 0xb9, 0x0d, 0x29, 0xf2, 0x81, 0xf6, 0x0f,
						0x2a, 0xb2, 0xd7, 0x7c, 0xfb, 0x92, 0xfc, 0x60,
						0x08, 0x04, 0xdc, 0x0f, 0x64, 0x02, 0x96, 0x5c,
						0x56, 0xe3, 0xfb, 0x67, 0xc8, 0x6a, 0x28, 0x17,
					},
					/* decodingParameters = */ []byte{
						0x3d, 0x1e, 0xe3, 0x1c, 0x9b, 0x2f, 0x40, 0xeb,
						0xb1, 0x83, 0x08, 0x4e,
					},
				),
			),
		)
		testutil.RequireEqualStatus(t, status.Error(codes.Internal, "Failed to resolve tag with key hash 2LkNKfKB9g8qstd8-5L8YAgE3A9kApZcVuP7Z8hqKBc.PR7jHJsvQOuxgwhO: Storage failure"), err)

		// Let's try this again. Except that now the write fails.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x9a, 0x1c, 0x03, 0xaa, 0x5d, 0x87, 0x5a, 0xa3,
					0xe0, 0x61, 0x35, 0x55, 0xf7, 0x62, 0xa0, 0x55,
					0x6d, 0x04, 0xdd, 0x82, 0xfa, 0x9f, 0x2d, 0xdb,
					0x32, 0x36, 0x2e, 0xb0, 0x2c, 0x8f, 0xbf, 0x99,
				},
			},
			/* minimumTimestamp = */ nil,
		).DoAndReturn(func(ctx context.Context, referenceFormat object.ReferenceFormat, key tag.Key, minimumTimestamp *time.Time) (tag.SignedValue, bool, error) {
			<-ctx.Done()
			require.Equal(t, context.Canceled, ctx.Err())
			return tag.SignedValue{}, false, status.Error(codes.Canceled, "Request canceled")
		})
		objectEncoder.EXPECT().EncodeBinary(
			/* input = */ []byte{0x12, 0x06, 0x08, 0xbf, 0xf8, 0xee, 0x84, 0x06},
			/* decodingParameters = */ []byte{0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a, 0x57, 0xe3, 0xd9, 0x06},
		).Return([]byte{0xa6, 0xed, 0x16, 0xdd, 0x82, 0x27, 0xc5, 0x4d}, nil)
		clock.EXPECT().Now().Return(time.Unix(1620819007, 0))
		dagUploader.EXPECT().UploadTaggedDAG(
			gomock.Any(),
			struct{}{},
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
					0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
					0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
					0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
				},
			},
			tag.SignedValue{
				Value: tag.Value{
					Reference: object.MustNewSHA256V1LocalReference("572b3a27c3d52fc3eed60c1e591a6477e29a1ca24eb03f87dcade2cdfdc0cf09", 8, 0, 0, 0),
					Timestamp: time.Unix(1620819007, 0),
				},
				Signature: [...]byte{
					0x1a, 0xff, 0x84, 0xd9, 0xc4, 0x6c, 0x89, 0xe9,
					0x4a, 0xd3, 0xfa, 0x1d, 0x7f, 0x69, 0xf9, 0x41,
					0xf0, 0x67, 0x91, 0xf7, 0x77, 0xcd, 0xdc, 0xb1,
					0xb5, 0xd7, 0x72, 0xd7, 0xd0, 0x1b, 0x3f, 0x63,
					0xa7, 0xf3, 0xb9, 0xb5, 0x52, 0x0c, 0xed, 0x80,
					0xea, 0x72, 0x4a, 0x4a, 0x0c, 0x02, 0xfd, 0x62,
					0x31, 0xe9, 0x76, 0x42, 0xb0, 0x0d, 0xb8, 0x2f,
					0x3e, 0x93, 0x4b, 0x67, 0x77, 0x7d, 0x6e, 0x05,
				},
			},
			gomock.Any(),
		).DoAndReturn(func(ctx context.Context, namespace struct{}, rootTagKey tag.Key, rootTagSignedValue tag.SignedValue, rootObjectContentsWalker dag.ObjectContentsWalker) error {
			rootObjectContentsWalker.Discard()
			return status.Error(codes.Internal, "Storage failure")
		})

		_, err = store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0x9a, 0x1c, 0x03, 0xaa, 0x5d, 0x87, 0x5a, 0xa3,
						0xe0, 0x61, 0x35, 0x55, 0xf7, 0x62, 0xa0, 0x55,
						0x6d, 0x04, 0xdd, 0x82, 0xfa, 0x9f, 0x2d, 0xdb,
						0x32, 0x36, 0x2e, 0xb0, 0x2c, 0x8f, 0xbf, 0x99,
					},
					/* decodingParameters = */ []byte{
						0xc9, 0x9f, 0xdf, 0x2a, 0x9b, 0x4f, 0xfb, 0x5c,
						0x04, 0x45, 0xfe, 0xb1,
					},
				),
			),
		)
		testutil.RequireEqualStatus(t, status.Error(codes.Internal, "Failed to upload tag with key hash D1rlh6ZXCfdIBffCZ5HZJ5fiXXyc5enA6mLMOK-cIAY.PjUIeCREbBpX49kG: Storage failure"), err)

		// Now we let both the read and write succeed.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x9a, 0x1c, 0x03, 0xaa, 0x5d, 0x87, 0x5a, 0xa3,
					0xe0, 0x61, 0x35, 0x55, 0xf7, 0x62, 0xa0, 0x55,
					0x6d, 0x04, 0xdd, 0x82, 0xfa, 0x9f, 0x2d, 0xdb,
					0x32, 0x36, 0x2e, 0xb0, 0x2c, 0x8f, 0xbf, 0x99,
				},
			},
			/* minimumTimestamp = */ nil,
		).Return(tag.SignedValue{}, false, status.Error(codes.NotFound, "Tag does not exist"))
		objectEncoder.EXPECT().EncodeBinary(
			/* input = */ []byte{0x12, 0x06, 0x08, 0xbf, 0xf8, 0xee, 0x84, 0x06},
			/* decodingParameters = */ []byte{0x3e, 0x35, 0x08, 0x78, 0x24, 0x44, 0x6c, 0x1a, 0x57, 0xe3, 0xd9, 0x06},
		).Return([]byte{0xa6, 0xed, 0x16, 0xdd, 0x82, 0x27, 0xc5, 0x4d}, nil)
		clock.EXPECT().Now().Return(time.Unix(1620819007, 0))
		dagUploader.EXPECT().UploadTaggedDAG(
			gomock.Any(),
			struct{}{},
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0x0f, 0x5a, 0xe5, 0x87, 0xa6, 0x57, 0x09, 0xf7,
					0x48, 0x05, 0xf7, 0xc2, 0x67, 0x91, 0xd9, 0x27,
					0x97, 0xe2, 0x5d, 0x7c, 0x9c, 0xe5, 0xe9, 0xc0,
					0xea, 0x62, 0xcc, 0x38, 0xaf, 0x9c, 0x20, 0x06,
				},
			},
			tag.SignedValue{
				Value: tag.Value{
					Reference: object.MustNewSHA256V1LocalReference("572b3a27c3d52fc3eed60c1e591a6477e29a1ca24eb03f87dcade2cdfdc0cf09", 8, 0, 0, 0),
					Timestamp: time.Unix(1620819007, 0),
				},
				Signature: [...]byte{
					0x1a, 0xff, 0x84, 0xd9, 0xc4, 0x6c, 0x89, 0xe9,
					0x4a, 0xd3, 0xfa, 0x1d, 0x7f, 0x69, 0xf9, 0x41,
					0xf0, 0x67, 0x91, 0xf7, 0x77, 0xcd, 0xdc, 0xb1,
					0xb5, 0xd7, 0x72, 0xd7, 0xd0, 0x1b, 0x3f, 0x63,
					0xa7, 0xf3, 0xb9, 0xb5, 0x52, 0x0c, 0xed, 0x80,
					0xea, 0x72, 0x4a, 0x4a, 0x0c, 0x02, 0xfd, 0x62,
					0x31, 0xe9, 0x76, 0x42, 0xb0, 0x0d, 0xb8, 0x2f,
					0x3e, 0x93, 0x4b, 0x67, 0x77, 0x7d, 0x6e, 0x05,
				},
			},
			gomock.Any(),
		).DoAndReturn(func(ctx context.Context, namespace struct{}, rootTagKey tag.Key, rootTagSignedValue tag.SignedValue, rootObjectContentsWalker dag.ObjectContentsWalker) error {
			contents, walkers, err := rootObjectContentsWalker.GetContents(ctx)
			require.NoError(t, err)
			require.Equal(t, []byte{0xa6, 0xed, 0x16, 0xdd, 0x82, 0x27, 0xc5, 0x4d}, contents.GetFullData())
			require.Empty(t, walkers)
			return nil
		})

		handle4, err := store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0x9a, 0x1c, 0x03, 0xaa, 0x5d, 0x87, 0x5a, 0xa3,
						0xe0, 0x61, 0x35, 0x55, 0xf7, 0x62, 0xa0, 0x55,
						0x6d, 0x04, 0xdd, 0x82, 0xfa, 0x9f, 0x2d, 0xdb,
						0x32, 0x36, 0x2e, 0xb0, 0x2c, 0x8f, 0xbf, 0x99,
					},
					/* decodingParameters = */ []byte{
						0x49, 0xf3, 0x76, 0xcb, 0x01, 0xf5, 0x08, 0x12,
						0x37, 0xa3, 0x39, 0x8e,
					},
				),
			),
		)
		require.NoError(t, err)

		handle4.Release(false)

		// With the write having completed successfully, future
		// attempts to access the store should no longer try to
		// write the released handle.
		tagResolver.EXPECT().ResolveTag(
			gomock.Any(),
			object.SHA256V1ReferenceFormat,
			tag.Key{
				SignaturePublicKey: [...]byte{
					0x89, 0xcb, 0x11, 0xf5, 0xf8, 0x35, 0x57, 0x9d,
					0x2c, 0x85, 0x5e, 0xbe, 0xff, 0xf1, 0xf3, 0x32,
					0x16, 0xef, 0x55, 0x1e, 0xa5, 0xa9, 0xf3, 0xd5,
					0xa8, 0x97, 0x1d, 0x97, 0x1d, 0x60, 0x75, 0x39,
				},
				Hash: [...]byte{
					0xde, 0x7d, 0xbc, 0x9b, 0x90, 0xe8, 0x0e, 0x9a,
					0xf0, 0xa9, 0x91, 0x58, 0xa7, 0x88, 0xe3, 0x64,
					0x53, 0x26, 0x81, 0x80, 0x0a, 0xc1, 0x18, 0x3f,
					0xbf, 0x40, 0x6c, 0xac, 0x3a, 0x05, 0x9f, 0x8a,
				},
			},
			/* minimumTimestamp = */ nil,
		).Return(tag.SignedValue{}, false, status.Error(codes.NotFound, "Tag does not exist"))

		handle5, err := store.Get(
			ctx,
			util.Must(
				model_core.NewDecodable(
					/* tagKeyHash = */ [...]byte{
						0xde, 0x7d, 0xbc, 0x9b, 0x90, 0xe8, 0x0e, 0x9a,
						0xf0, 0xa9, 0x91, 0x58, 0xa7, 0x88, 0xe3, 0x64,
						0x53, 0x26, 0x81, 0x80, 0x0a, 0xc1, 0x18, 0x3f,
						0xbf, 0x40, 0x6c, 0xac, 0x3a, 0x05, 0x9f, 0x8a,
					},
					/* decodingParameters = */ []byte{
						0xa3, 0xe0, 0x8b, 0x3f, 0xe1, 0x0f, 0x5c, 0x75,
						0x1a, 0x15, 0x1e, 0xba,
					},
				),
			),
		)
		require.NoError(t, err)

		handle5.Release(false)
	})
}
