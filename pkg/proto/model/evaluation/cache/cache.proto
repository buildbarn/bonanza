syntax = "proto3";

package bonanza.model.evaluation.cache;

import "bonanza.build/pkg/proto/model/core/core.proto";
import "bonanza.build/pkg/proto/model/evaluation/evaluation.proto";
import "bonanza.build/pkg/proto/model/tag/tag.proto";
import "google/protobuf/timestamp.proto";

option go_package = "bonanza.build/pkg/proto/model/evaluation/cache";

message ActionTagKeyData {
  // Common parameters that need to be considered when computing a tag
  // key hash.
  bonanza.model.tag.CommonKeyData common_tag_key_data = 1;

  // Homomorphic hash of the references of keys for which overrides were
  // specified in the bonanza.model.evaluation.Action message.
  bytes key_references_with_overrides_hash = 2;
}

message DependenciesHashRecord {
  // Reference of the key for which evaluation was performed.
  bonanza.model.core.Reference key_reference = 1;

  oneof value {
    // The message value, in case evaluation of the function is expected
    // to yield one.
    bonanza.model.core.Any message_value = 2;

    // In case evaluation of the function yielded a native value, the
    // homomorphic hash of the keys and values of all dependencies that
    // were accessed during evaluation.
    bytes native_value_dependencies_hash = 3;
  }
}

message LookupTagKeyData {
  // Reference to the ActionTagKeyData message containing parameters
  // shared across all tag key hashes belonging to a single
  // bonanza.model.evaluation.Action.
  bonanza.model.core.Reference action_tag_key_reference = 1;

  // Reference to the evaluation key for which a cache lookup is being
  // performed.
  bonanza.model.core.Reference evaluation_key_reference = 2;

  message SubsequentLookup {
    enum Scope {
      INVALID = 0;

      // The 'dependencies_hash' field was computed respecting the
      // 'graphlet_dependency_keys'.
      GRAPHLET = 1;

      // The 'dependencies_hash' field was computed respecting the
      // 'value_dependency_keys'.
      VALUE = 2;
    }

    // Whether a cache lookup at the graphlet or key level is being
    // performed.
    Scope scope = 1;

    // Homomorphic hash of the keys and values of all dependencies of
    // the key that have been gathered up to this point.
    bytes dependencies_hash = 2;
  }

  // If set, this is not the initial lookup that is being performed for
  // this key, as a previous lookup yielded 'missing_dependencies'.
  SubsequentLookup subsequent_lookup = 3;
}

message LookupResult {
  message Initial {
    // Non-empty expected set of dependencies of the graphlet rooted at
    // the current key. Only keys whose values are variable (i.e.,
    // transitively dependent on keys for which overrides are present)
    // are included.
    repeated bonanza.model.evaluation.Keys graphlet_variable_dependency_keys =
        1;

    // Non-empty expected set of direct dependencies of the current key.
    // Only keys whose values are variable (i.e., transitively dependent
    // on keys for which overrides are present) are included.
    repeated bonanza.model.evaluation.Keys value_variable_dependency_keys = 2;

    // If set, there is a probability that subsequent lookups will require
    // specifying even more dependencies. This field denotes the time at
    // which this started to occur.
    //
    // If a sufficient amount of time has passed, it may be desirable to
    // overwrite the existing lookup results with a single entry that
    // contains no indirection. This ensures that the amount of
    // indirection does not continue to grow over time.
    google.protobuf.Timestamp contains_indirection_since = 3;
  }

  message MissingDependencies {
    // Non-empty set of additional dependencies for which values needs
    // to be computed, so that another lookup can be attempted. Only
    // keys whose values are variable (i.e., transitively dependent on
    // keys for which overrides are present) are included.
    repeated bonanza.model.evaluation.Keys additional_variable_dependency_keys =
        1;
  }

  oneof result {
    // The entry that is returned when an initial lookup is performed,
    // and the key has a non-empty set of dependencies. It stores the
    // expected set of dependencies of both the key and the graphlet
    // rooted at the current key.
    Initial initial = 1;

    // The set of dependencies returned by the previous lookup(s) were
    // incomplete. This can happen if the set of dependencies of the key
    // is not always the same. The previous lookup(s) only returned the
    // keys that are shared by all evaluations. Now an additional lookup
    // needs to be performed, incorporating the values of even more
    // dependencies.
    MissingDependencies missing_dependencies = 2;

    // All provided dependencies of the graphlet rooted at the current
    // key match previously observed values, meaning that a previously
    // computed graphlet can be used.
    bonanza.model.evaluation.Graphlet hit_graphlet = 3;

    // All provided dependencies of the current key match previously
    // observed values, meaning that a previously computed value can be
    // used.
    //
    // This may also be returned as part of the initial lookup if the
    // requested key does not have any dependencies.
    bonanza.model.core.Any hit_value = 4;
  }
}
